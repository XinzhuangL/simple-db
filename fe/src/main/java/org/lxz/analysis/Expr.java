package org.lxz.analysis;

import org.lxz.catalog.Function;
import org.lxz.catalog.Type;
import org.lxz.common.TreeNode;
import org.lxz.sql.parser.NodePosition;

import java.util.Collections;
import java.util.List;

/**
 * Root of the expr node hierarchy.
 */
public abstract class Expr extends TreeNode<Expr> implements ParseNode {

    // Name of the function that needs to be implemented by every Expr that
    // supports negation.
    protected static final String NEGATE_FN = "negate";

    // to be used where can't come up with a better estimate
    protected static final double DEFAULT_SELECTIVITY = 0.1;

    public static final float FUNCTION_CALL_COST = 10;

    // id that's unique across the entire query statement and is assigned by
    // Analyzer.registerConjuncts(); only assigned for the top-level terms of a
    // conjunction, and therefore null for most Exprs
    protected ExprId id;

    // true if Expr is an auxiliary predicate that was generated by the plan generation
    // process to facilitate predicate propagation
    // false if Expr originated with a query stmt directly
    protected boolean isAuxExpr = false;

    protected final NodePosition pos;

    protected Type type; // result of analysis

    // only for query result set metadata
    // set if related to an actual column
    protected Type originType;

    protected boolean isOnClauseConjunct_; // set by analyzer

    protected boolean isAnalyzed = false; // true after analyze() has been called


    // todo thrift property

    // estimated probability of a predicate evaluating to true
    // set during analysis
    // between 0 and 1 if valid: invalid: -1
    protected double selectivity;

    // estimated number of distinct values produced by Expr; invalid: -1
    // set during analysis
    protected long numDistinctValues;

    protected int outputScale = -1;
    protected int outputColumn = -1;

    protected boolean isFilter = false;

    // The function to call. This can either be a scalar or aggregate function.
    // Set in analyze().
    protected Function fn;

    // Ignore nulls
    protected boolean ignoreNulls = false;

    // Cached value of IsConstant(), set during analyze() and valid if isAnalyzed_ is true.
    protected boolean isConstant_;

    // Flag to indicate whether to wrap this expr's toSql() in parenthesis. Set by parser.
    // Needed for properly capturing expr precedences in the SQL string.
    protected boolean printSqlInParens = false;

    protected List<String> hints = Collections.emptyList();

    // protected RoaringBitMap cachedUsedSlotIds = null;

    // is this Expr can be used in index filter and expr filter or only index filter
    // passed to BE storage engine
    protected boolean isIndexOnlyFilter = false;



    // todo impl later
    public static Function getBuiltinFunction(String name, Type[] argTypes, Function.CompareMode mode) {
        return null;
    }



    /**
     * Resets the internal analysis state of this expr tree. Removes implicit casts.
     */
    public Expr reset() {
        // todo do nothing
        return this;
    }


    protected Expr() {
        pos = NodePosition.ZERO;
    }
    protected Expr(NodePosition pos) {
        this.pos = pos;
        // todo other prop
    }

    @Override
    public NodePosition getPos() {
        return pos;
    }

    public void setType(Type type) {
        this.type = type;
    }

    public Type getType() {
        return type;
    }

    // Whether the expr itself is nullable
    public boolean isNullable() {
        return true;
    }


}
